---
layout: page
title: "CSC 4100 Notes -- Ch. 26, 27 -- Concurrency & Threads"
permalink: /notes/csc4100/ch2627
theme: jekyll-theme-hacker
---

# CSC 4100 Notes -- Ch. 26 -- Concurrency

## Recall the following information about processes

- Processes have their own program counters (PC)

- Processes have their own page directory base registers (PDBR)

- Processes have their own address space

- Information about processes is stored in the process struct (aka the process control block)

## Some initial thoughts about threads

* In contrast to our single-threaded view of computation, our programs might have more than one point of execution. This is handled with threads. 

* We can thus think of threads like separate processes, except for the fact that they share the same address space and can access the same data.

* Threads, like processes, undergo context switches. State information about threads is, therefore, stored in a similar manner to processes in the Thread Control Block. 

* When we undergo a context switch between threads, we do not change the PDBR.

* Note that we do still have to change the PC.

## Primary emphases when thinking about threads      (*Probable Exam Question)

1. Theads have the same address space

2. Uncontrolled Scheduling

## Multi-Threaded Address Space

| Program Code |
|:------------:|
| Heap         |
| (free)       |
| Stack 1      |
| (free)       |
| Stack 2      |

Another major difference between threads and processes concerns the stack; in a multi-threaded process, each thread runs independently, and thus needs to have its own stack for local variables, etc.

Note that it is okay for threads to share program code, as we expect threads to be a part of the same process. To account for this, each thread will have its own stack. Recall that the stack is a special region of memory that stores local/temporary variables created by functions, and is a LIFO data structure.

As we can see, the only place that remains for problems to arise is in the heap. Recall that the heap contains global variables, dynamically allocated memory, and so on, and is a FIFO data structure. Once memory is allocated on the heap, the programmer is responsible for deallocating it to avoid memory leaks.

## Why bother with threads? (*Probable Exam Question)

1. <u>Parallelization</u> -- multiple threads, divide and conquer. Solve problems in parallel  and save time

2. <u>I/O</u> -- we can perform context switches on threads to deal with I/O, just like we did with processes.

## Thread Creation Code

```c
/* Note that this syntax is particularly useful.
 * Because procedures are often used by multiple threads,
 * a return type and parameter of void * allow us to pass
 * in and return essentially arbitrary data */

void *mythread(void *arg)
{
    printf("%s\n", (char *) arg);
    return NULL;
}

int main(int argc, char *argv[])
{
    pthread_t p1, p2;
    int rc;
    
    printf("main: begin\n");
    
    /* &p1 -- process 
     * NULL -- special options
     * mythread -- procedure we want to run
     * "A" -- arguments to passs */
    Pthread_create(&p1, NULL, mythread, "A");
    Pthread_create(&p2, NULL, mythread, "B");
    
    /* Join waits for the threads to finish.
     * Because threads run independently of one another,
     * and what runs next is determined by the OS scheduler,
     * we cannot be sure what runs next, even if the scheduler
     * algorithm is robust and well-designed. */
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);

    printf("main: end\n");

    return 0;
}
```

<img src="file:///home/lainon/Downloads/figure.png" title="" alt="figure.png" data-align="center">

<img src="file:///home/lainon/Downloads/trace3.png" title="" alt="trace3.png" data-align="center">



## But wait, there's more!

```c
#include <stdio.h>
#include <pthread.h>
#include "common.h"
#include "common_threads.h"

static volataile int counter = 0;

//Add one to counter repeatedly, up to 10,000,000
void *mythread(void *arg)
{
    printf("%s: done\n", (char *) arg);
    
    int i;
    for (i=0; i<1e7; i++)
    {
        counter = counter +1;
    }
    
    printf("%s: done\n", (char*) arg);
    
    return NULL;
}
int main(int argc, char*argv[]) 
{
    pthread_t p1, p2;

    printf("main: begin (counter = %d)\n", counter);

    Pthread_create(&p1, NULL, mythread, "A");
    Pthread_create(&p2, NULL, mythread, "B");
    
    // join waits for the threads to finish
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);

    printf("main: done with both (counter = %d)\n", counter);
    
    return 0;
}

/* When we run this code, even on a single processor,
 * we do not always get the desired result of 20,000,000,
 * as a result of the shenanigans threads get up to.
 * Computers don't always produce deterministic results!
 */
```



## The Heart of the Problem: Uncontrolled Scheduling

```nasm
mov 0x8049a1c, %eax
add $0x1, %eax
mov $eax, 0x8049a1c
```

Suppose that one of our threads enters this section of our code and is going to increment our counter. The value of our counter is first loaded into the register eax, and then 1 is added. If a timer interrupt goes off, the state of the currently running threa is saved. 

Â If our second thread is chosen by our scheduler to run next, and thus enters the same segment of our code, it will execute the first instruction to move the value of our counter into its eax. The value of counter is, at this point, still 50, as the interrupt prevented thread 1 from restoring the new value of eax. The value of counter is then incremented and restored as 51.

If another context switch happens, and thread 1 resumes, it will execute the final mov instruction, despite the fact that its eax is also 51 (it cannot account for the fact that thread 2 incremented the counter). Thus, 51 is restored into our counter and it is as though we only incremented it once.

This type of occurence is called a <u>race condition</u> (more specifically, a <u>data race</u>). Code that can result in a race condition is known as a <u>critical section</u>. Our goal is to only allow one thread in a critical section at a time.

In order to prevent a data race, we want to satisfy the property of <u>mutual exclusion</u>. This property ensures that when a thread is executing within a critical section, other threads will be locked out of doing so.



<img src="file:///home/lainon/Downloads/atomicity.png" title="" alt="atomicity.png" data-align="center">

# Some Notes from Ch. 27 -- Thread Creation

In order to write multi-threaded programs, you must be able to create threads. Thus an operating system must define a thread creation interface. Implementations, such as the POSIX implementation, can be relatively simple.



> NAME
>        pthread_create - thread creation
> SYNOPSIS
>        #include <pthread.h>
>        int pthread_create(pthread_t *restrict thread,
>               const pthread_attr_t *restrict attr,
>               void *(*start_routine)(void*), void *restrict arg);
> DESCRIPTION
>        The   pthread_create()   function  shall  create  a  new  thread,  with
>        attributes specified by attr, within a process. If attr  is  NULL,  the
>        default  attributes  shall be used. If the attributes specified by attr
>        are modified later, the thread's attributes shall not be affected. Upon
>        successful  completion, pthread_create() shall store the ID of the cre-
>        ated thread in the location referenced by thread.
>        The thread is created executing start_routine  with  arg  as  its  sole
>        argument. If the start_routine returns, the effect shall be as if there
>        was an implicit call  to  pthread_exit()  using  the  return  value  of
>        start_routine  as the exit status. Note that the thread in which main()
>        was originally invoked differs from this. When it returns from  main(),
>        the  effect  shall  be as if there was an implicit call to exit() using
>        the return value of main() as the exit status.
> 
> 
> 
> - pthread_create arguments:
>   
>   - thread: An opaque, unique identifier for the new thread 
>     returned by the subroutine.
>   
>   - attr: An opaque attribute object that may be used to set 
>     thread attributes. You can specify a thread attributes object, or 
>     NULL for the default values.
>   
>   - start_routine: the C routine that the thread will
>      execute once it is created.
>   
>   - arg: A single argument that may be passed to 
>     *start_routine*. It must be passed by reference as a pointer 
>     cast of type void. NULL may be used if no argument is to be passed.
>     
>     
>     
>     Sources: https://computing.llnl.gov/tutorials/pthreads/man/pthread_create.txt
>     
>     https://computing.llnl.gov/tutorials/pthreads/#CreatingThreads



## Creating a Thread

```c
#include <stdio.h>
#include<pthread.h>

typedef struct
{
    int a;
    int b;
} myarg_t;


void *mythread(void *arg)
{
    myarg_t *args = (myarg_t *) arg;

    printf("%d %d\n", args->a, args->b);
    
    return NULL;
}

int main(int argc, char *argv[])
{
    pthread_t p;
    
    myarg_t args = {10, 20};

    int rc = pthread_create(&p, NULL, mythread, &args);
    ...
}
```


